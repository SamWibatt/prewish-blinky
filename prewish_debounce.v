CURRENTLY BROKEN or at least badly in need of proofreading
the idea is that you can have a slow_clk of whatever an appropriate value is, I'm thinking ~20Hz, generated by the caller
It can use a clock_div from here if it wants, or whatever else it is that it uses
I SHOULD EXPERIMENT WITH SB_GB CLOCK THINGS AND SEE IF I CAN MAKE A SINGLE MEISTER CLOCK WITH A FEW DIVIDED DOWN LINES ALL ROUTED LIKE CLOCKS

// I should test this piece %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// debouncer for the buttons and swicths that input our mask and stuff.
// per https://www.fpga4student.com/2017/04/simple-debouncing-verilog-code-for.html

// here's their way of doing async laundering through two dffs:

//first this:
// D-flip-flop for debouncing module 
module my_dff(input DFF_CLOCK, D, output reg Q);
    always @ (posedge DFF_CLOCK) begin
        Q <= D;
    end
endmodule
	

// Slow clock for debouncing, hardcoded 12 MHz assumption and divide clock by 19 bits =~ 22Hz.
// web page as written has a mad slow like 4Hz debounce clock, I remember favoring 10s of Hz, super nintendo style
// WILL NEED RESET IF I STICK WITH THIS
module clock_div(input Clk_in, output slow_clk

    );
	parameter SYSCLK_DIV_BITS = 19;				//parameterize other stuff up once 
	reg [SYSCLK_DIV_BITS-1:0]counter=0;
	always @(posedge Clk_in)
    begin
        //decimal rollover ew counter <= (counter>=249999)?0:counter+1;
        //slow_clk <= (counter < 125000)?1'b0:1'b1;
		//my way
		counter <= counter + 1;
    end
	
	//they had slow_clk as output reg
	assign slow_clk = counter[SYSCLK_DIV_BITS-1];
endmodule

//is there any reason not to just have one of these per button?
//the clock divider gets wasteful. I will pull it out.
module debounce(input pb_1,slow_clk,output pb_out);
	//wire slow_clk;
	//clock_div u1(clk,slow_clk);		//caller will supply slow clock.
	wire Q1,Q2,Q2_bar;

	//I suspect I'll need a chunk like these 4 lines for every input.
	//also instead of assigning wires at the end, stick these in registers
	//for polling to pick up on
	//can do an interrupty one later that has like direct reset button input or wev
	//is that a good choice for a for loop, verilog-style? LOOK INTO IT!
	my_dff d1(slow_clk, pb_1,Q1 );
	my_dff d2(slow_clk, Q1,Q2 );
	assign Q2_bar = ~Q2;
	assign pb_out = Q1 & Q2_bar;
	//end need a chunk like these 4
endmodule

